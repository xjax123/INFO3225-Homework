/* autogenerated by Processing revision 1293 on 2024-02-28 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Project1 extends PApplet {

SimulationController controller = new SimulationController();
PhysicsBody testing = new PhysicsCircle(15000,0.9f,new PVector(400,400),40.0f);
PhysicsBody testing2 = new PhysicsCircle(1.0f,0.9f,new PVector(200,400),new PhysVector(vecScalarMulti(PVector.random2D(),15.0f)),20.0f);
PhysicsBody testing3 = new PhysicsCircle(100.0f,0.9f,new PVector(600,400),new PhysVector(vecScalarMulti(PVector.random2D(),15.0f)),10.0f);
PhysicsBody testing4 = new PhysicsCircle(10.0f,0.9f,new PVector(300,200),new PhysVector(vecScalarMulti(PVector.random2D(),15.0f)),60.0f);

boolean devmode = false;

public void setup() {
    /* size commented out by preprocessor */;
    frameRate(60);
    controller.startEmptySim(new PVector(0,0), new PVector(800,800),500);
    controller.addActor(testing);
    controller.addActor(testing2);
    controller.addActor(testing3);
    controller.addActor(testing4);
}

public void draw() {
    background(255);
    controller.startDraw();
}

public void keyPressed() {
    if (key == CODED) {
        if (keyCode == UP) {
            testing.impulse(new PVector(0,-5));
        }
        if (keyCode == DOWN) {
            testing.impulse(new PVector(0,5));
        }
        if (keyCode == LEFT) {
            testing.impulse(new PVector(-5,0));
        }
        if (keyCode == RIGHT) {
            testing.impulse(new PVector(5,0));
        }

    }
    if (key == 10) {
        if (devmode == false) {
            devmode = true;
        } else {
            devmode = false;
        }
    }
}
PhysicsBody selected;
public void mousePressed() {
    selected = controller.objectAtPoint(new PVector(mouseX,mouseY));
}
public void mouseReleased() {
    if (selected != null) {
        selected.setGravityMode(true);
        selected = null;
    }
}
public class PhysVector {
    private float x; //what direction its going vertically, normalized to between 1 and -1
    private float y; //what direction its going vertically, normalized to between 1 and -1
    private float velocity; //how fast its going, in M/s

    //create an empty vector
    public PhysVector() {
        x = 0;
        y = 0;
        velocity = 0;
    }
    //Create a Physvector from its component parts
    //x and y's absolute values should add up to equal roughly 1.0, otherwise this will potentially create strange behavior
    public PhysVector(float _x, float _y, float _velocity) {
        x = _x;
        y = _y;
        velocity = _velocity;
    }
    //create a PhysVector from a Pvector
    public PhysVector(PVector vec) {
        float tv = abs(vec.x)+abs(vec.y);
        velocity = tv;
        x = physNormalize(vec.x,-tv,tv);
        y = physNormalize(vec.y,-tv,tv);
    }

    //various useful getters
    public PVector totalSpeed() {
        return new PVector(velocity*x,velocity*y);
    }
    public float speedX() {
        return x*velocity;
    }
    public float speedY() {
        return y*velocity;
    }
    public float unitX() {
        return x;
    }
    public float unitY() {
        return y;
    }
    public float getVelocity() {
        return velocity;
    }
    public PVector unitVector() {
        return new PVector(x,y);
    }
    public float direction() {
        return degrees(atan2(x,y));
    }

    //Setters
    public void set(float _x, float _y, float _velocity) {
        x = _x;
        y = _y;
        velocity = _velocity;
    }
    public void setX(float _x) {
        x = _x;
    }
    public void setY(float _y) {
        y = _y;
    }
    public void setVelocity(float _velocity) {
        velocity = _velocity;
    }

    //Applying an impulse of force
    public void impulse(PVector v) {
        PVector total = this.totalSpeed();
        total.x = total.x+v.x;
        total.y = total.y+v.y;
        float tv = total.x+total.y;
        velocity = tv;
        x = physNormalize(total.x,-tv,tv);
        y = physNormalize(total.y,-tv,tv);
    }
    public void impulse(PhysVector v) {
        impulse(v.totalSpeed());
    }

    @Override
    public String toString() {
        return "[ X:"+this.x+", Y:"+this.y+", Velocity: "+this.velocity+"]";
    }
}
public class AABB {
    public float minx, maxx, miny, maxy;

    public AABB(float _minx, float _maxx, float _miny, float _maxy) {
        minx = _minx;
        maxx = _maxx;
        miny = _miny;
        maxy = _maxy;
    }
}

public abstract class PhysicsBody {
    protected float mass;
    protected float elasticity = 1; //should be from 0 [Completely Inelastic] to 1 [Completely Elastic], retains that much of its total energy each collision.
    protected PVector position;
    protected AABB axisBox;
    protected AABB nextAxisBox;
    protected PhysVector vector;
    protected PVector nextPos;
    protected boolean gravity = true;
    protected ArrayList<PhysicsBody> colls = new ArrayList<PhysicsBody>();
    

    public PhysicsBody(float _mass, PVector _position) {
        mass = _mass;
        position = _position;
        vector = new PhysVector();
    }
    public PhysicsBody(float _mass, PVector _position, PhysVector _vector) {
        mass = _mass;
        position = _position;
        vector = _vector;
    }
    public PhysicsBody(float _mass, float _elasticity, PVector _position) {
        mass = _mass;
        position = _position;
        elasticity = _elasticity;
        vector = new PhysVector();
    }
    public PhysicsBody(float _mass, float _elasticity, PVector _position, PhysVector _vector) {
        mass = _mass;
        position = _position;
        elasticity = _elasticity;
        vector = _vector;
    }

    //Geters
    public PVector getPosition() {
        return position;
    }
    public PhysVector getVector() {
        return vector;
    }
    public float getMass() {
        return mass;
    }
    public PVector getNextPos() {
        return nextPos;
    }
    public boolean gravityAffected() {
        return gravity;
    }

    //Seters
    public void move(PVector v) {
        position = v;
        calcAABB();
    }
    public void setVector(PhysVector v) {
        vector = v;
    }
    public void setNextPos(PVector v) {
        nextPos = v;
    }
    public void setGravityMode(boolean b) {
        gravity = b;
    }

    public void startstep(float freq, float scale) {
        PVector tv = vector.totalSpeed();
        tv.x = (tv.x*scale)/freq;
        tv.y = (tv.y*scale)/freq;
        nextPos = new PVector(0,0);
        nextPos.x = position.x+tv.x;
        nextPos.y = position.y+tv.y;
        calcNextAABB();
    }
    public void endstep() {
        move(new PVector(nextPos.x,nextPos.y));
    }

    public void impulse(PVector v) {
        vector.impulse(v);
    }
    public void impulse(PhysVector v) {
        vector.impulse(v);
    }
    public abstract void draw();
    public abstract void calcAABB();
    public abstract void calcNextAABB();
    public abstract void checkCollision(ArrayList<PhysicsBody> actors, PVector bound1, PVector bound2, float freq, float scale);
}

public class PhysicsCircle extends PhysicsBody {
    private float radius;
    private int col = color(0);

    public PhysicsCircle(float _mass, PVector _position, float _radius) {
        super(_mass,_position);
        radius = _radius;
        calcAABB();
        nextPos = position;
        calcNextAABB();
    }
    public PhysicsCircle(float _mass, PVector _position, PhysVector _vector, float _radius) {
        super(_mass,_position, _vector);
        radius = _radius;
        calcAABB();
        nextPos = position;
        calcNextAABB();
    }
    public PhysicsCircle(float _mass, float _elasticity, PVector _position, float _radius) {
        super(_mass,_elasticity,_position);
        radius = _radius;
        calcAABB();
        nextPos = position;
        calcNextAABB();
    }
    public PhysicsCircle(float _mass, float _elasticity, PVector _position, PhysVector _vector, float _radius) {
        super(_mass,_elasticity,_position, _vector);
        radius = _radius;
        calcAABB();
        nextPos = position;
        calcNextAABB();
    }

    @Override
    public void checkCollision(ArrayList<PhysicsBody> actors, PVector bound1, PVector bound2, float freq, float scale) {
        for(PhysicsBody actor : actors) {
            if (this == actor) {
                continue;
            }
            if (nextAxisBox.maxx >= actor.nextAxisBox.minx && actor.nextAxisBox.maxx >= nextAxisBox.minx && nextAxisBox.maxy >= actor.nextAxisBox.miny && actor.nextAxisBox.maxy >= nextAxisBox.miny) {
                if (actor instanceof PhysicsCircle) {
                    PhysicsCircle circle = (PhysicsCircle) actor;
                    float colDist = radius+circle.radius;
                    float dist = distance(nextPos.x,nextPos.y,actor.nextPos.x,actor.nextPos.y);
                    //something here is causing "stickiness" with other objects
                    if (dist <= colDist) {
                        collide(circle,freq,scale);
                    }
                }
            } 
        }
        if (nextPos.x-radius < bound1.x) {
            float unx = vector.unitX()*-1;
            float vel = vector.getVelocity();
            vector.setVelocity(vel*elasticity);
            vector.setX(unx);
            nextPos.x = bound1.x+radius;
        }
        if (nextPos.x+radius > bound2.x) {
            float unx = vector.unitX()*-1;
            float vel = vector.getVelocity();
            vector.setVelocity(vel*elasticity);
            vector.setX(unx);
            nextPos.x = bound2.x-radius;
        }
        if (nextPos.y-radius < bound1.y) {
            float uny = vector.unitY()*-1;
            float vel = vector.getVelocity();
            vector.setVelocity(vel*elasticity);
            vector.setY(uny);
            nextPos.y = bound1.y+radius;
        }
        if (nextPos.y+radius > bound2.y) {
            float uny = vector.unitY()*-1;
            float vel = vector.getVelocity();
            vector.setVelocity(vel*elasticity);
            vector.setY(uny);
            nextPos.y = bound2.y-radius;
        }
    }

    //collisions fucking suck
    public void collide(PhysicsBody b, float freq, float scale) {
        PVector tv = vector.totalSpeed();
        PVector otv = b.getVector().totalSpeed();
        float contactAngle = degrees(atan2(nextPos.x-b.nextPos.x,nextPos.y-b.nextPos.y)); //I think this is accurate, hopefully.
        float vx1 = tv.x;
        float vx2 = otv.x;
        float vy1 = tv.y;
        float vy2 = otv.y;
        float d1 = vector.direction();
        float d2 = b.getVector().direction();
        float m1 = mass;
        float m2 = b.getMass();
        //im pretty sure this equason is leaking velocity, but the fixed version is doing better.
        //objects are still unnaturally "Sticky" and will clump together.
        float fx = ((vx1*cos(d1-contactAngle)*(m1-m2)+(2*m2*vx2)*cos(d2-contactAngle))/(m1+m2))*cos(contactAngle)+vx1*sin(d1-contactAngle)*cos(contactAngle+(PI/2));
        float fy = ((vy1*cos(d1-contactAngle)*(m1-m2)+(2*m2*vy2)*cos(d2-contactAngle))/(m1+m2))*sin(contactAngle)+vy1*sin(d1-contactAngle)*sin(contactAngle+(PI/2)); 
        vector = new PhysVector(new PVector(fx,fy));
    }
    float buffer = 4;
    public void calcAABB() {
        axisBox = new AABB(position.x-radius-buffer,position.x+radius+buffer,position.y-radius-buffer,position.y+radius+buffer);
    }
    public void calcNextAABB() {
        nextAxisBox = new AABB(nextPos.x-radius-buffer,nextPos.x+radius+buffer,nextPos.y-radius-buffer,nextPos.y+radius+buffer);
    }

    public void draw(){
        fill(col);
        circle(position.x, position.y, radius*2);
        if (devmode == true) {
            noFill();
            beginShape();
            vertex(axisBox.minx,axisBox.miny);
            vertex(axisBox.maxx,axisBox.miny);
            vertex(axisBox.maxx,axisBox.maxy);
            vertex(axisBox.minx,axisBox.maxy);
            endShape(CLOSE);
            beginShape();
            vertex(nextAxisBox.minx,nextAxisBox.miny);
            vertex(nextAxisBox.maxx,nextAxisBox.miny);
            vertex(nextAxisBox.maxx,nextAxisBox.maxy);
            vertex(nextAxisBox.minx,nextAxisBox.maxy);
            endShape(CLOSE);
        }
    }
}
//normalizes to between 1 and -1
public float physNormalize(float data, float min, float max) {
    return (2*(data-min)/(max-min))-1;
}

public float distance(float x1, float y1, float x2, float y2) {
    return (float) Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));
}

public float vecDot(PVector v1, PVector v2) {
    float x = v1.x*v2.x;
    float y = v1.y*v2.y;
    return x+y;
}
public PVector vecAdd(PVector v1, PVector v2) {
    return new PVector(v1.x+v2.x,v1.y+v2.y);
}
public PVector vecSub(PVector v1, PVector v2) {
    return new PVector(v1.x-v2.x,v1.y-v2.y);
}
public PVector vecMulti(PVector v1, PVector v2) {
    return new PVector(v1.x*v2.x,v1.y*v2.y);
}
public PVector vecDiv(PVector v1, PVector v2) {
    return new PVector(v1.x/v2.x,v1.y/v2.y);
}
public PVector vecScalarAdd(PVector v, float s) {
    return new PVector(v.x+s,v.y+s);
}
public PVector vecScalarSub(PVector v, float s) {
    return new PVector(v.x-s,v.y-s);
}
public PVector vecScalarMulti(PVector v, float s) {
    return new PVector(v.x*s,v.y*s);
}
public PVector vecScalarDiv(PVector v, float s) {
    return new PVector(v.x/s,v.y/s);
}
public PVector vecPow (PVector v, float power) {
    return new PVector((float) Math.pow(v.x,power), (float) Math.pow(v.y,power));
}






public class SimulationController {
    private Simulation activeSim;
    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    ScheduledFuture<?> simHandler;

    public SimulationController() {}

    private final Runnable sim = new Runnable() {
        public void run() {
            try {
                activeSim.step();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    };

    public void startEmptySim(PVector bound1, PVector bound2, float simFreq) {
        activeSim = new Simulation(simFreq,bound1,bound2);
        simHandler = scheduler.scheduleAtFixedRate(sim,(long) 0, (long) Math.round(1000/simFreq), TimeUnit.MILLISECONDS);
    }

    public void endSim() {
        simHandler.cancel(true);
    }

    public void startDraw() {
        activeSim.draw();
    }

    public void addActor(PhysicsBody body) {
        activeSim.addActor(body);
    }

    public void addActors(ArrayList<PhysicsBody> bodies) {
        for (PhysicsBody body : bodies) {
            activeSim.addActor(body);
        }
    }

    public PhysicsBody objectAtPoint(PVector v) {
        return activeSim.objectAtPoint(v);
    }

    private class Simulation {
        ArrayList<PhysicsBody> actors = new ArrayList<PhysicsBody>();
        float freqency; //what the frequency of the simulation is, important for physics calculations. 
        PVector gravity = new PVector(0,9.8f); //Gravity in the scene, defaulted to earth's in M/s
        PVector normGravity; //gravity normalized to the frequency. precomputed to save time.
        float scale = 500; //How many pixels equates to a meter. Used for calculating speeds.
        float airDensity = 1.225f; //density of the air, defaulted to earth at sea level
        private final ExecutorService workPool = Executors.newCachedThreadPool();
        PVector bound1;
        PVector bound2;

        public Simulation(float simFreq, PVector _bound1, PVector _bound2) {
            freqency = simFreq;
            bound1 = _bound1;
            bound2 = _bound2;
            normGravity = new PVector(gravity.x/simFreq,gravity.y/simFreq);
        }

        public Simulation(float simFreq, PVector _bound1, PVector _bound2, PVector _gravity) {
            freqency = simFreq;
            bound1 = _bound1;
            bound2 = _bound2;
            gravity = _gravity;
            normGravity = new PVector(_gravity.x/simFreq,_gravity.y/simFreq);
        }

        public Simulation(float simFreq, PVector _bound1, PVector _bound2, PVector _gravity, float _scale) {
            freqency = simFreq;
            bound1 = _bound1;
            bound2 = _bound2;
            gravity = _gravity;
            scale = _scale;
            normGravity = new PVector(_gravity.x/simFreq,_gravity.y/simFreq);
        }

        public void addActor(PhysicsBody b) {
            actors.add(b);
        }

        public PhysicsBody objectAtPoint(PVector v) {
            for(PhysicsBody actor : actors) {
                if (v.x >= actor.nextAxisBox.minx && actor.nextAxisBox.maxx >= v.x && v.y >= actor.nextAxisBox.miny && actor.nextAxisBox.maxy >= v.y) {
                    return actor;
                }
            }
            return null;
        }


        public void step() {
            if (selected != null) {
                selected.setVector(new PhysVector());
                selected.setGravityMode(false);
                selected.position.x = mouseX;
                selected.position.y = mouseY;
            }
            for (PhysicsBody actor : actors) {
                if (actor.gravityAffected() == true) {
                    actor.impulse(normGravity);
                }
                actor.startstep(freqency, scale);
                actor.checkCollision(actors,bound1,bound2,freqency,scale);
                actor.endstep();
            }
        }

        public void draw() {
            for (PhysicsBody actor : actors) {
                actor.draw();
            }
        }
    }
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Project1" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
