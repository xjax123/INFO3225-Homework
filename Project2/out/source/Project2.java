/* autogenerated by Processing revision 1293 on 2024-04-07 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.function.Consumer;
import java.util.Arrays;
import java.util.HashMap;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Project2 extends PApplet {




float camRotY;
PShader lighting;
PGraphics main,hud;
SceneManager manager = new SceneManager();
String devText = "";
ArrayList<ReferencedLamda> functionManager = new ArrayList<ReferencedLamda>();
boolean holding = false;

public void setup() {
    /* size commented out by preprocessor */;
    frameRate(60);
    main = createGraphics(1920,1061,P3D);
    main.smooth(8);
    hud = createGraphics(1920,1080,P2D);
    noStroke();

    //Shaders, still experementing with/testing these
    /*
    lighting = loadShader("./shaders/Lighting/lightingFrag.glsl","./shaders/Lighting/lightingVert.glsl");
    lighting.set("ambientColor", 150f, 150f, 150f);
    lighting.set("ambientStrength",1f);
    lighting.set("lightColor", 200f, 200f, 200f);
    lighting.set("lightDir", 0.2f, -1f, 0.6f);
    lighting.set("specStrength", 1f);
    lighting.set("viewPos",-200,-650,-400);*/


    //Generating Tiles, could in theory be put into a JSON to be loaded for later use.
    defineTiles();

    //Generating Entities, could in theory be put into a JSON to be loaded for later use.
    defineEntities();

    //Generating Maps
    defineMaps();

    //Generating Hud Elements
    defineHudElements();
}

public void draw() {
    main.beginDraw();

    if (holding) {
        keyHeld();
    }

    //Background & Lighting
    main.background(50,50,60);
    main.ambientLight(150, 150, 150);
    main.directionalLight(200, 200, 200, -0.2f, 1, -0.6f);

    //load main shader
    //main.shader(lighting);

    //Camera
    main.beginCamera();
    main.camera();
    main.translate(1920/2,1080/2,0);
    main.rotateX(radians(-55));
    main.rotateY(radians(-20+camRotY));
    main.endCamera();
    //scene offset
    //dev marks, useful as a reference
    /*
    main.stroke(0, 255, 0, 255);
    main.strokeWeight(2);
    main.line(0, -1000, 0, 0, 1000, 0);
    main.stroke(255, 0, 0, 255);
    main.line(-1000, 0, 0, 1000, 0, 0);
    main.stroke(0, 0, 255, 255);
    main.line(0, 0, -1000, 0, 0, 1000);
    main.noStroke();
    main.fill(255);
    main.pushMatrix();
    main.translate(200,-650,400);
    main.sphere(10);
    main.popMatrix(); */

    //translating the scene to the center of the screen & drawing
    main.translate(-manager.getActiveMap().tiles.length*0.5f*50,0,-manager.getActiveMap().tiles[0].length*0.5f*50);
    int size = functionManager.size();
    ArrayList<ReferencedLamda> cleanup = new ArrayList<ReferencedLamda>();
    for(int x = 0; x < size; x++) {
        ReferencedLamda r = functionManager.get(x);
        r.run();
        cleanup.add(r);
    }
    for (ReferencedLamda r : cleanup) {
        functionManager.remove(r);
    }
    cleanup = new ArrayList<ReferencedLamda>();
    manager.getActiveMap().drawMap(main);
    main.endDraw();

    hud.beginDraw();
    hud.background(0,0,0,0);
    hud.noStroke();
    hud.fill(255, 255, 255);
    hud.textSize(64);
    hud.text("Current Pos: "+devText, 0, 64);
    hud.text("Current State: "+manager.getPlayer().state, 0, 128);
    hud.endDraw();

    image(main,0,0);
    image(hud,0,0);
}

public void keyPressed() {
    holding = true;
    if (key == 'r') {
        manager.reload();
    }
    if (key == 10) {
        manager.nextScene();
    }
    keyHeld();
}

public void keyReleased() {
    holding = false;    
}

public void keyHeld() {
    NavMap act = manager.getActiveMap();
    if (key == 'w') {
        try {
            if (act.checkEnt(act.getPlayer(),Direction.UP)) {
                act.getPlayer().playAnimation("walkUp");
            }
        } catch (Exception e) {
            println(e.toString());
        }
    }
    if (key == 's') {
        try {
            if (act.checkEnt(act.getPlayer(),Direction.DOWN)) {
                act.getPlayer().playAnimation("walkDown");
            }
        } catch (Exception e) {
            println(e.toString());
        }
    }
    if (key == 'a') {
        try {
            if (act.checkEnt(act.getPlayer(),Direction.LEFT)) {
                act.getPlayer().playAnimation("walkLeft");
            }
        } catch (Exception e) {
            println(e.toString());
        }
    }
    if (key == 'd') {
        try {
            if (act.checkEnt(act.getPlayer(),Direction.RIGHT)) {
                act.getPlayer().playAnimation("walkRight");
            }
        } catch (Exception e) {
            println(e.toString());
        }
    }
    if (key == 'q') {
        camRotY += 5;
    }
    if (key == 'e') {
        camRotY -= 5;
    }
    if (camRotY < 0) {
        camRotY += 360;
    }
    if (camRotY > 360) {
        camRotY -= 360;
    }
}
enum AnimationState {
    PAUSED,
    PLAYING,
    FINISHED,
    WAITING,
    BUFFER,
    PENDING
}

class Animation {
    String name;
    KeyFrame[] kfs;
    int currentIndex = 0;
    public boolean looping;
    public boolean interuptable;
    public boolean moving; 
    public boolean forceInterupt;
    public EntFunction fin;
    public EntFunction start;
    float totalTime = 0;
    float elapsedTime = 0;
    float curTime = 0;
    float curRotX = 0;
    float curRotY = 0;
    float curRotZ = 0;
    float curScale = 1;
    PVector curTranslate = new PVector(0,0,0);
    KeyFrame prevFrame;
    KeyFrame targetFrame;
    public AnimationState state = AnimationState.WAITING;
    public Animation(String _name, KeyFrame[] _kfs, boolean _looping, boolean _interuptable, boolean _moving, EntFunction _start, EntFunction end) {
        name = _name;
        kfs = _kfs;
        looping = _looping;
        prevFrame = new KeyFrame(curTime, curRotX, curRotY, curRotZ, curScale, curTranslate);
        targetFrame = kfs[currentIndex];
        fin = end;
        start = _start;
        interuptable = _interuptable;
        moving = _moving;
        for (KeyFrame k : kfs) {
            totalTime += k.time;
        }
    }    
    public Animation(String _name, KeyFrame[] _kfs, boolean _looping, boolean _interuptable, boolean _moving, EntFunction _start, EntFunction end, boolean _forceInterupt) {
        name = _name;
        kfs = _kfs;
        looping = _looping;
        prevFrame = new KeyFrame(curTime, curRotX, curRotY, curRotZ, curScale, curTranslate);
        targetFrame = kfs[currentIndex];
        fin = end;
        start = _start;
        interuptable = _interuptable;
        moving = _moving;
        forceInterupt = _forceInterupt;
        for (KeyFrame k : kfs) {
            totalTime += k.time;
        }
    }
    public Animation(Animation a) {
        name = a.name;
        kfs = a.getKeyframes();
        looping = a.looping;
        curTime = 0;
        curRotX = 0;
        curRotY = 0;
        curRotZ = 0;
        curScale = 1;
        curTranslate = new PVector(0,0,0);
        prevFrame = new KeyFrame(curTime, curRotX, curRotY, curRotZ, curScale, curTranslate);
        targetFrame = kfs[currentIndex];
        fin = a.fin;
        start = a.start;
        interuptable = a.interuptable;
        moving = a.moving;
        state = AnimationState.WAITING;
        totalTime = a.totalTime;
    }

    public KeyFrame[] getKeyframes() {
        return kfs;
    }

    public KeyFrame getCurrentKeyframe() {
        return kfs[currentIndex];
    }

    public int getCurrentIndex() {
        return currentIndex;
    }

    public float getPerFinished() {
        return animNormalize(elapsedTime,0,totalTime);
    }

    public void play(MapEntitiy ent) {
        functionManager.add(new ReferencedLamda(start,ent,this,LambdaType.START));
    }

    public void pause() {
        state = AnimationState.PAUSED;
    }

    public void unpause() {
        state = AnimationState.PLAYING;
    }

    public void step(PGraphics buffer, MapEntitiy ent) {
        if (state == AnimationState.FINISHED || state == AnimationState.PAUSED || state == AnimationState.WAITING) {
            return;
        }

        if (curTime >= targetFrame.time) {
            if (currentIndex+1 < kfs.length) {
                curTime = 0;
                currentIndex +=1;
                prevFrame = targetFrame;
                targetFrame = kfs[currentIndex];
            } else {
                if (looping == true) {
                    curTime = 0;
                    currentIndex = 0;
                    curTime = 0;
                    curRotX = 0;
                    curRotY = 0;
                    curRotZ = 0;
                    curScale = 1;
                    curTranslate = new PVector(0,0,0);
                    prevFrame = new KeyFrame(curTime, curRotX, curRotY, curRotZ, curScale, curTranslate);
                    targetFrame = kfs[currentIndex];
                } else if (state == AnimationState.PLAYING) {
                    onFinish(ent);
                }
            }
        }

        float comPer = animNormalize(curTime,0,targetFrame.time);
        curRotX = prevFrame.rotX + (targetFrame.rotX-prevFrame.rotX)*comPer;
        curRotY = prevFrame.rotY + (targetFrame.rotY-prevFrame.rotY)*comPer;
        curRotZ = prevFrame.rotZ + (targetFrame.rotZ-prevFrame.rotZ)*comPer;
        curTranslate.x = prevFrame.translate.x + (targetFrame.translate.x-prevFrame.translate.x)*comPer;
        curTranslate.y = prevFrame.translate.y + (targetFrame.translate.y-prevFrame.translate.y)*comPer;
        curTranslate.z = prevFrame.translate.z + (targetFrame.translate.z-prevFrame.translate.z)*comPer;
        curScale = prevFrame.scale + (targetFrame.scale-prevFrame.scale)*comPer;
        buffer.scale(curScale);
        buffer.translate(curTranslate.x,curTranslate.y,curTranslate.z);
        buffer.rotateX(radians(curRotX));
        buffer.rotateY(radians(curRotY));
        buffer.rotateZ(radians(curRotZ));
        
        curTime += 1;
        elapsedTime += 1;
    }

    public void onFinish(MapEntitiy ent) {
        functionManager.add(new ReferencedLamda(fin,ent,this,LambdaType.FINISH));
    }

    @Override
    public String toString() {
        String temp = "[";
        for (KeyFrame k : kfs) {
            temp += k.toString();
            temp += ", ";
        }
        temp += "]";
        return temp;
    }
}

class KeyFrame {
    public float time;
    public float rotX;
    public float rotY;
    public float rotZ;
    public float scale;
    public PVector translate;

    public KeyFrame(float _time, float _rotX, float _rotY, float _rotZ, float _scale, PVector _translate) {
        time = _time;
        rotX = _rotX;
        rotY = _rotY;
        rotZ = _rotZ;
        scale = _scale;
        translate = _translate;
    }

    @Override
    public String toString() {
        return "[t:"+time+", rotX: "+rotX+", rotY: "+rotY+", rotZ: "+rotZ+", translate: "+translate.toString()+"]";
    }
}

public float animNormalize(float data, float min, float max) {
    return ((data-min)/(max-min));
}

interface EntFunction {
    void run(MapEntitiy m);
}

enum LambdaType {
    START,
    FINISH
}

class ReferencedLamda {
    EntFunction func;
    MapEntitiy ent;
    Animation a;
    LambdaType type;

    public ReferencedLamda(EntFunction _func, MapEntitiy _ent, Animation _a, LambdaType _type) {
        func = _func;
        ent = _ent;
        a = _a;
        type = _type;
    }

    public void run() {
        func.run(ent);
        if (type == LambdaType.START) {
            a.state = AnimationState.PLAYING;
        } else if (type == LambdaType.FINISH) {
            a.state = AnimationState.FINISHED;
        }
    }
}


HashMap<Character, MapTile> tileMap = new HashMap<Character, MapTile>();
HashMap<String, MapEntitiy> entityMap = new HashMap<String, MapEntitiy>();

enum Direction {
    UP,
    DOWN,
    LEFT,
    RIGHT
};

enum AIState {
    WAITING,
    ACTING
}

class NavMap {
    MapTile[][] tiles;
    ArrayList<MapEntitiy> entities = new ArrayList<MapEntitiy>();;

    public NavMap(NavMap map) {
        tiles = new MapTile[map.tiles.length][map.tiles[0].length];
        for (int x = 0; x < tiles.length; x++) {
            for (int y = 0; y < tiles[x].length; y++) {
                if (map.tiles[x][y] == null) {
                    tiles[x][y] = new MapTile();
                } else {
                    MapTile tile = map.tiles[x][y];
                    tiles[x][y] = tileCopy(tile);
                }
                if (map.entities != null) {
                    ArrayList<MapEntitiy> ents = map.getEnts(x,y);
                    for (MapEntitiy ent : ents) {
                        entities.add(entityCopy(ent));
                    }
                }
            }
        }
    }

    public NavMap(Character[][] _mapTiles) {
        int max = 0;
        for (int i = 0; i < _mapTiles.length; i++) {
            if (_mapTiles[i].length > max) {
                max = _mapTiles[i].length;
            }
        }
        tiles = new MapTile[_mapTiles.length][max];
        for (int x = 0; x < tiles.length; x++) {
            for (int y = 0; y < tiles[x].length; y++) {
                if (_mapTiles[x][y] == null || _mapTiles[x][y] == 'b') {
                    tiles[x][y] = new MapTile();
                } else {
                    MapTile tile = tileMap.get(_mapTiles[x][y]);
                    tiles[x][y] = tileCopy(tile);
                }
            }
        }
    }

    public boolean inBounds(int x, int y) {
        if (x >= 0 && x < tiles.length) {
            if (y >= 0 && y < tiles[0].length) {
                return true;
            }
        }
        return false;
    }

    public MapEntitiy getPlayer() {
        for (int x = 0; x < tiles.length; x++) {
            for (int y = 0; y < tiles[x].length; y++) {
                ArrayList<MapEntitiy> ents = getEnts(x,y);
                for (MapEntitiy ent : ents) {
                    if (ent instanceof Player) {
                        return ent;
                    }
                }
            }
        }
        return null;
    }

    public ArrayList<MapEntitiy> getEnts(int x, int y) {
        ArrayList<MapEntitiy> map = new ArrayList<MapEntitiy>();
        for (MapEntitiy ent : entities) {
            if (ent.mapX == x) {
                if (ent.mapY == y) {
                    map.add(ent);
                }
            }
        }
        return map;
    }
    public void registerEntity(MapEntitiy ent, int x, int y) {
        MapEntitiy newEnt = entityCopy(ent);
        entities.add(newEnt);
        newEnt.mapX = x;
        newEnt.mapY = y;
        newEnt.walkTile(tiles[x][y]);
    }

    public void positionEnt(MapEntitiy ent, int newX, int newY) {
        ent.mapX = newX;
        ent.mapY = newY;
    }
    //remember to update to include collision detection
    public void moveEnt(MapEntitiy ent, Direction d) {
        if (ent.state == EntState.DEAD) {
            return;
        }
        int x = ent.mapX;
        int y = ent.mapY;
        if (d == Direction.UP) {
            int newY = y-1;
            if (inBounds(x,newY)) {
                if (ent.canWalk(tiles[x][newY])) {
                    ent.walkTile(tiles[x][newY]);
                    positionEnt(ent,x,newY);
                }
            }
        } else if (d == Direction.DOWN) {
            int newY = y+1;
            if (inBounds(x,newY)) {
                if (ent.canWalk(tiles[x][newY])) {
                    ent.walkTile(tiles[x][newY]);
                    positionEnt(ent,x,newY);
                }       
            }
        } else if (d == Direction.LEFT) {
            int newX = x-1;
            if (inBounds(newX,y)) {
                if (ent.canWalk(tiles[newX][y])) {
                    ent.walkTile(tiles[newX][y]);
                    positionEnt(ent,newX,y);
                }
            }
        } else if (d == Direction.RIGHT) {
            int newX = x+1;
            if (inBounds(newX,y)) {
                if (ent.canWalk(tiles[newX][y])) {
                    ent.walkTile(tiles[newX][y]);
                    positionEnt(ent,newX,y);
                }
            }
        }
    }

    public boolean checkEnt(MapEntitiy ent, Direction d) {
        if (ent.state == EntState.DEAD) {
            return false;
        }

        if (d == Direction.UP) {
            int newY = ent.mapY-1;
            if (inBounds(ent.mapX,newY)) {
                if (ent.canWalk(tiles[ent.mapX][newY])) {
                    return true;
                }
            }
        } else if (d == Direction.DOWN) {
            int newY = ent.mapY+1;
            if (inBounds(ent.mapX,newY)) {
                if (ent.canWalk(tiles[ent.mapX][newY])) {
                    return true;
                }       
            }
        } else if (d == Direction.LEFT) {
            int newX = ent.mapX-1;
            if (inBounds(newX,ent.mapY)) {
                if (ent.canWalk(tiles[newX][ent.mapY])) {
                    return true;
                }
            }
        } else if (d == Direction.RIGHT) {
            int newX = ent.mapX+1;
            if (inBounds(newX,ent.mapY)) {
                if (ent.canWalk(tiles[newX][ent.mapY])) {
                    return true;
                }
            }
        }
        return false;
    }

    public void drawMap(PGraphics buffer) {
        buffer.pushMatrix();
            for (int x = 0; x < tiles.length; x++) {
                buffer.translate(50,0,0);
                buffer.pushMatrix();
                    for (int y = 0; y < tiles[x].length; y++) {
                        buffer.translate(0,0,50);
                        ArrayList<MapEntitiy> ents = getEnts(x,y);
                        for (MapEntitiy ent : ents) {
                            if (ent != null) {
                                if (ent.visible) {
                                    aiCall(ent);
                                    buffer.pushMatrix();
                                    ent.animate(buffer);
                                    ent.draw(buffer);
                                    buffer.popMatrix();
                                }
                            }
                        }
                        if (tiles[x][y].visible) {
                            buffer.shape(tiles[x][y].shape,0,0);
                        }
                    }
                buffer.popMatrix();
            }
        buffer.popMatrix();
    }

    @Override
    public String toString() {
        String smap = "";
        smap += "[";
        for (int x = 0; x < tiles.length; x++) {
            smap += "{";
            for (int y = 0; y < tiles[x].length; y++) {
                smap += tiles[x][y].toString();
            }
            smap += "}";
        }
        smap += "]";
        return smap;
    }
}

//Tile Classes & Utils
class MapTile {
    public Character identifier;
    public PShape shape = createShape();
    public boolean walkable = false;
    public boolean visible = true;

    public MapTile() {
        identifier = 'b';
    }
    public MapTile(MapTile copy) {
        identifier = copy.identifier;
        shape = copy.shape;
        walkable = copy.walkable;
    }
    public MapTile(Character id, PShape _shape) {
        identifier = id;
        shape = _shape;
    }
    public MapTile(Character id, PShape _shape, boolean _walkable) {
        identifier = id;
        shape = _shape;
        walkable = _walkable;
    }

    public void setVisible(boolean b) {
        visible = b;
    }

    @Override
    public String toString() {
        return identifier.toString();
    }
}

class DangerTile extends MapTile {
    public DangerTile(MapTile copy) {
        super(copy);
    }
    public DangerTile(Character id, PShape _shape) {
        super(id,_shape,true);
    }
}
class WinTile extends MapTile {
    public WinTile(MapTile copy) {
        super(copy);
    }
    public WinTile(Character id, PShape _shape) {
        super(id,_shape,true);
    }
}

public MapTile tileCopy(MapTile tile) {
    MapTile mt;
    if (tile instanceof DangerTile) {
        mt = new DangerTile(tile);
    } else if (tile instanceof WinTile) {
        mt = new WinTile(tile);
    } else {
        mt = new MapTile(tile);
    }
    return mt;
}

//Entity Classes & Utils
enum EntState {
    ALIVE,
    DEAD
}

class MapEntitiy {
    public int mapX;
    public int intendedX;
    public int mapY;
    public int intendedY;
    public PShape shape;
    public EntState state = EntState.ALIVE;
    public boolean visible = true;
    public HashMap<String, Animation> animations = new HashMap<String, Animation>();
    public ArrayList<Animation> activeAnimations = new ArrayList<Animation>();

    public MapEntitiy(MapEntitiy ent) {
        mapX = ent.mapX;
        mapY = ent.mapY;
        shape = ent.shape;
        state = ent.state;
        visible = ent.visible;
        animations = ent.animations;
    }
    public MapEntitiy(int _x, int _y, PShape _shape) {
        mapX = _x;
        mapY = _y;
        shape = _shape;
    }

    public boolean canWalk(MapTile tile) {
        if (tile.walkable) {
            return true;
        } else {
            return false;
        }
    }

    public void walkTile(MapTile tile) {}

    public void checkColide(int x, int y) {
        ArrayList<MapEntitiy> ents = manager.getActiveMap().getEnts(x,y);
        for (MapEntitiy ent : ents) {
            if (ent == this) {
                break;
            }
            if (ent.activeAnimations.size() == 0 || ent.activeAnimations.get(0).state == AnimationState.FINISHED || !ent.activeAnimations.get(0).moving) { 
                if (ent.mapX == x && ent.mapY == y) {
                    collide(ent);
                }
            } else if (ent.activeAnimations.get(0).getPerFinished() < 0.2f) {
                if (ent.intendedX == x && ent.intendedY == y) {
                    collide(ent);
                } else if (ent.mapX == x && ent.mapY == y) {
                    collide(ent);
                }
            }
        }
    }

    public void collide(MapEntitiy ent) {}

    public void kill() {
        state = EntState.DEAD;
        visible = false;
    }

    public void playAnimation(String t) throws Exception {
        Animation a = animations.get(t);
        for (Animation activeAnimation : activeAnimations) {
            if (activeAnimation.state != AnimationState.FINISHED) {
                if (!a.forceInterupt && !activeAnimation.interuptable) {
                    return;
                }
                if (activeAnimation.name == a.name) {
                    return;
                }
            }
        }
        if (a == null) {
            throw new Exception("Error: Tried To Invoke Animation That Does Not Exit.");
        }
        println("Finihsed Checks");
        Animation anim = new Animation(a);
        activeAnimations.add(anim);
        anim.play(this);
    }    
    public void registerAnimation(String t, Animation a) {
        animations.put(t,a);
    }

    public void draw(PGraphics buffer) {
        buffer.shape(shape,0,0);
    }

    public void animate(PGraphics buffer) {
        for (Animation activeAnimation : activeAnimations) {
            if (activeAnimation.state != AnimationState.FINISHED) {
                activeAnimation.step(buffer, this);
            }
        }
        int size = activeAnimations.size();
        for (int x = 0; x < size-1; x++) {
            Animation a = activeAnimations.get(x);
            if (a.state == AnimationState.FINISHED) {
                activeAnimations.remove(a);
            }
        }
    }
}

class Player extends MapEntitiy {
    public Player(Player ent) {
        super(ent);
    }
    public Player(int _x, int _y, PShape _shape) {
        super(_x,_y,_shape);
    }

    @Override
    public void collide(MapEntitiy ent) {
        try {
            playAnimation("normalDeath");
        } catch (Exception e) {
            println(e.toString());
        }
    }

    @Override
    public void walkTile(MapTile tile) {
        super.walkTile(tile);
        devText = "Walking on - "+tile.identifier.toString();
        if (tile instanceof DangerTile) {
            try {
                playAnimation("lavaDeath");
            } catch (Exception e) {
                println(e.toString());
            }
        }
        if (tile instanceof WinTile) {
            manager.nextScene();
        }
    }
}

class AIEntity extends MapEntitiy {
    public int moveFreq = 1;
    public int step = 0;
    AIState ai = AIState.WAITING;

    public AIEntity(AIEntity ent) {
        super(ent);
        moveFreq = ent.moveFreq;
        ai = AIState.WAITING;
    }
    
    public AIEntity(int _x, int _y, PShape _shape, int freq) {
        super(_x,_y,_shape);
        moveFreq = freq;
        ai = AIState.WAITING;
    }

    public void stepAI() {}
}

class LineEnemy extends AIEntity {
    Direction dir;
    public LineEnemy(LineEnemy ent) {
        super(ent);
        dir = ent.dir;
    }
    
    public LineEnemy(int _x, int _y, PShape _shape, int freq, Direction d) {
        super(_x,_y,_shape, freq);
        dir = d;
    }

    @Override
    public void collide(MapEntitiy ent) {
        if (ent == this) {
            return;
        }

        if (ent instanceof Player) {
            try{
                ent.playAnimation("normalDeath");
            } catch (Exception e) {
                println(e.toString());
            }
        } else {
            try{
                playAnimation("turnAround");
            } catch (Exception e) {
                println(e.toString());
            }
        }
    }

    @Override
    public void stepAI() {
        if (ai == AIState.WAITING) {
            if (step == moveFreq) {
                step = 0;
                ai = AIState.ACTING;
                if (manager.getActiveMap().checkEnt(this, dir)) {
                    try {
                        if (dir == Direction.UP) {
                            playAnimation("walkUp");
                        } else if (dir == Direction.DOWN) {
                            playAnimation("walkDown");
                        } else if (dir == Direction.LEFT) {
                            playAnimation("walkLeft");
                        } else if (dir == Direction.RIGHT) {
                            playAnimation("walkRight");
                        } 
                    } catch (Exception e) {
                        println(e.toString());
                    }
                } else {
                    try {
                        playAnimation("turnAround");
                    } catch (Exception e) {
                        println(e.toString());
                    }
                }
            } else {
                try {
                    playAnimation("idle");
                    ai = AIState.ACTING;
                } catch (Exception e) {
                    println(e.toString());
                }
            }
            step += 1;
        }
    }

}

public MapEntitiy entityCopy(MapEntitiy ent) {
    MapEntitiy me;
    if (ent instanceof Player) {
        me = new Player((Player) ent);
    } else if (ent instanceof LineEnemy) {
        me = new LineEnemy((LineEnemy) ent);
    } else if (ent instanceof AIEntity) {
        me = new AIEntity((AIEntity) ent);
    } else {
        me = new MapEntitiy(ent);
    }
    return me;
}

public void aiCall(MapEntitiy ent) {
    if (ent instanceof LineEnemy) {
        LineEnemy a = (LineEnemy) ent;
        a.stepAI();
    }
}
class SceneManager {
    ArrayList<NavMap> maps = new ArrayList<NavMap>();
    int mapIndex = 0;
    MapEntitiy mainChar;
    NavMap activeMap;
    public SceneManager() {}

    public void registerMap(NavMap map) {
        maps.add(map);
        if (activeMap == null) {
           setActiveMap(map);
        }
    }

    public NavMap getActiveMap() {
        return activeMap;
    }

    public MapEntitiy getPlayer() {
        return mainChar;
    }
    public void reload() {
        setActiveMap(maps.get(mapIndex));
    }

    public void nextScene() {
        if (mapIndex+1 >= maps.size()) {
            mapIndex = -1;
        }
        mapIndex += 1;
        setActiveMap(maps.get(mapIndex));
    }

    private void setActiveMap(NavMap map) {
        activeMap = new NavMap(map);
        mainChar = activeMap.getPlayer();
    }
}
public void defineTiles() {
    fill(50);
    PShape shape1 = createShape(BOX,50,1,50);
    MapTile m1 = new MapTile('T',shape1,true);
    tileMap.put('T',m1);
    fill(100);
    PShape shape2 = createShape(BOX,50,1,50);
    MapTile m2 = new MapTile('F',shape2,true);
    tileMap.put('F',m2);
    fill(25);
    PShape shape3 = createShape(BOX,50,50,50);
    shape3.translate(0,-25,0);
    MapTile m3 = new MapTile('W',shape3);
    tileMap.put('W',m3);
    fill(0xFFFFA500);
    PShape shape4 = createShape(BOX,50,50,50);
    shape4.translate(0,24,0);
    MapTile m4 = new DangerTile('L',shape4);
    tileMap.put('L',m4);
    fill(0,255,0);
    PShape shape5 = createShape(BOX,50,1,50);
    MapTile m5 = new WinTile('V',shape5);
    tileMap.put('V',m5);
}

public void defineEntities() {
    //Defining Common Functions
    EntFunction entdie = (n) -> {
        println(n.toString() + " Dead");
        n.kill();
    };     
    EntFunction entnothing = (n) -> {};    
    EntFunction entStartUp = (n) -> {
        n.intendedX = n.mapX;
        n.intendedY = n.mapY-1;
    };
    EntFunction entStartDown = (n) -> {
        n.intendedX = n.mapX;
        n.intendedY = n.mapY+1;
    };
    EntFunction entStartLeft = (n) -> {
        n.intendedX = n.mapX-1;
        n.intendedY = n.mapY;
    };
    EntFunction entStartRight = (n) -> {
        n.intendedX = n.mapX+1;
        n.intendedY = n.mapY;
    };    
    EntFunction entStartUpCol = (n) -> {
        n.intendedX = n.mapX;
        n.intendedY = n.mapY-1;
        n.checkColide(n.intendedX,n.intendedY);
    };
    EntFunction entStartDownCol = (n) -> {
        n.intendedX = n.mapX;
        n.intendedY = n.mapY+1;
        n.checkColide(n.intendedX,n.intendedY);
    };
    EntFunction entStartLeftCol = (n) -> {
        n.intendedX = n.mapX-1;
        n.intendedY = n.mapY;
        n.checkColide(n.intendedX,n.intendedY);
    };
    EntFunction entStartRightCol = (n) -> {
        n.intendedX = n.mapX+1;
        n.intendedY = n.mapY;
        n.checkColide(n.intendedX,n.intendedY);
    };

    strokeWeight(1);
    stroke(0);
    fill(255,255,255);
    //creating Player
    PShape ent1 = createShape(BOX,40,40,40);
    ent1.translate(0,-21,0);
    Player e1 = new Player(0,0,ent1);
    //Designing Animations & Ending functions
    EntFunction walkUp = (n) -> {
        manager.getActiveMap().moveEnt(n,Direction.UP);
        n.checkColide(n.intendedX,n.intendedY);
    };
    EntFunction walkDown = (n) -> {
        manager.getActiveMap().moveEnt(n,Direction.DOWN);
        n.checkColide(n.intendedX,n.intendedY);
    };
    EntFunction walkLeft = (n) -> {
        manager.getActiveMap().moveEnt(n,Direction.LEFT);
        n.checkColide(n.intendedX,n.intendedY);
    };
    EntFunction walkRight = (n) -> {
        manager.getActiveMap().moveEnt(n,Direction.RIGHT);
        n.checkColide(n.intendedX,n.intendedY);
    };

    KeyFrame[] wuframes = {new KeyFrame(10,90,0,0,1,new PVector(0,-19,-30))};
    Animation aWalkUp = new Animation(
        "walkUp",
        wuframes,
        false,
        false,
        true,
        entStartUp,
        walkUp
    );
    KeyFrame[] wdframes = {new KeyFrame(10,-90,0,0,1,new PVector(0,-19,30))};
    Animation aWalkDown = new Animation(
        "walkDown",
        wdframes,
        false,
        false,
        true,
        entStartDown,
        walkDown
    );
    KeyFrame[] wlframes = {new KeyFrame(10,0,0,-90,1,new PVector(-30,-19,0))};
    Animation aWalkLeft = new Animation(
        "walkLeft",
        wlframes,
        false,
        false,
        true,
        entStartLeft,
        walkLeft
    );
    KeyFrame[] wrframes = {new KeyFrame(10,0,0,90,1,new PVector(30,-19,0))};
    Animation aWalkRight = new Animation(
        "walkRight",
        wrframes,
        false,
        false,
        true,
        entStartRight,
        walkRight
    );
    KeyFrame[] ldieframes = {new KeyFrame(70,0,0,0,1,new PVector(0,50,0))};
    Animation aLDie = new Animation(
        "lavaDeath",
        ldieframes,
        false,
        false,
        false,
        entnothing,
        entdie,
        true
    );
    KeyFrame[] ndieframes = {new KeyFrame(30,0,0,0,0,new PVector(0,0,0))};
    Animation aNDie = new Animation(
        "normalDeath",
        ndieframes,
        false,
        false,
        false,
        entnothing,
        entdie,
        true
    );
    //Registering Animations
    e1.registerAnimation("walkUp", aWalkUp);
    e1.registerAnimation("walkDown", aWalkDown);
    e1.registerAnimation("walkLeft", aWalkLeft);
    e1.registerAnimation("walkRight", aWalkRight);
    e1.registerAnimation("lavaDeath", aLDie);
    e1.registerAnimation("normalDeath", aNDie);
    //Registering Player to entity map for later use & reference
    entityMap.put("player",e1);

    //Creating Line Enemies
    fill(0xFFFF0000);
    PShape ent2 = createShape(BOX,20,40,20);
    ent2.translate(0,-21,0);
    LineEnemy e2 = new LineEnemy(0,0,ent2,2,Direction.UP);
    LineEnemy e3 = new LineEnemy(0,0,ent2,2,Direction.DOWN);
    LineEnemy e4 = new LineEnemy(0,0,ent2,2,Direction.LEFT);
    LineEnemy e5 = new LineEnemy(0,0,ent2,2,Direction.RIGHT);

    //Registering Enemy Functions
    EntFunction eIdle = (n) -> {
        AIEntity a = (AIEntity) n;
        a.ai = AIState.WAITING;
    };
    EntFunction enWalkUp = (n) -> {
        manager.getActiveMap().moveEnt(n,Direction.UP);
        n.checkColide(n.intendedX,n.intendedY);
        AIEntity a = (AIEntity) n;
        a.ai = AIState.WAITING;
    };
    EntFunction enWalkDown = (n) -> {
        manager.getActiveMap().moveEnt(n,Direction.DOWN);
        n.checkColide(n.intendedX,n.intendedY);
        AIEntity a = (AIEntity) n;
        a.ai = AIState.WAITING;
    };
    EntFunction enWalkLeft = (n) -> {
        manager.getActiveMap().moveEnt(n,Direction.LEFT);
        n.checkColide(n.intendedX,n.intendedY);
        AIEntity a = (AIEntity) n;
        a.ai = AIState.WAITING;
    };
    EntFunction enWalkRight = (n) -> {
        manager.getActiveMap().moveEnt(n,Direction.RIGHT);
        n.checkColide(n.intendedX,n.intendedY);
        AIEntity a = (AIEntity) n;
        a.ai = AIState.WAITING;
    };
    EntFunction enTurnAround = (n) -> {
        LineEnemy a = (LineEnemy) n;
        if (a.dir == Direction.UP) {
            a.dir = Direction.DOWN;
        } else if (a.dir == Direction.DOWN) {
            a.dir = Direction.UP;
        } else if (a.dir == Direction.LEFT) {
            a.dir = Direction.RIGHT;
        } else if (a.dir == Direction.RIGHT) {
            a.dir = Direction.LEFT;
        }
        a.ai = AIState.WAITING;
    };

    KeyFrame[] eidleframes = {new KeyFrame(10,0,0,0,1,new PVector(0,00,0)),new KeyFrame(5,0,0,0,1,new PVector(0,-10,0)), new KeyFrame(5,0,0,0,1,new PVector(0,0,0)),new KeyFrame(10,0,0,0,1,new PVector(0,0,0))};
    Animation aEnemyIdle = new Animation(
        "idle",
        eidleframes,
        false,
        true,
        false,
        entnothing,
        eIdle
    );    
    KeyFrame[] enTurnAroundframes = {new KeyFrame(5,0,90,0,1,new PVector(0,-10,0)), new KeyFrame(5,0,180,0,1,new PVector(0,0,0))};
    Animation aEnTurnAround = new Animation(
        "turnAround",
        enTurnAroundframes,
        false,
        false,
        false,
        entnothing,
        enTurnAround,
        true
    );
    KeyFrame[] enWalkUpframes = {new KeyFrame(5,0,0,0,1,new PVector(0,-10,-25)), new KeyFrame(5,0,0,0,1,new PVector(0,0,-50))};
    Animation aEnWalkUp = new Animation(
        "walkUp",
        enWalkUpframes,
        false,
        false,
        true,
        entStartUpCol,
        enWalkUp
    );
    KeyFrame[] enWalkDownframes = {new KeyFrame(5,0,0,0,1,new PVector(0,-10,25)),new KeyFrame(5,0,0,0,1,new PVector(0,0,50))};
    Animation aEnWalkDown = new Animation(
        "walkDown",
        enWalkDownframes,
        false,
        false,
        true,
        entStartDownCol,
        enWalkDown
    );
    KeyFrame[] enWalkLeftframes = {new KeyFrame(5,0,0,0,1,new PVector(-25,-10,0)),new KeyFrame(5,0,0,0,1,new PVector(-50,0,0))};
    Animation aEnWalkLeft = new Animation(
        "walkLeft",
        enWalkLeftframes,
        false,
        false,
        true,
        entStartLeftCol,
        enWalkLeft
    );
    KeyFrame[] enWalkRightframes = {new KeyFrame(5,0,0,0,1,new PVector(25,-10,0)), new KeyFrame(5,0,0,0,1,new PVector(50,0,0))};
    Animation aEnWalkRight = new Animation(
        "walkRight",
        enWalkRightframes,
        false,
        false,
        true,
        entStartRightCol,
        enWalkRight
    );
    e2.registerAnimation("idle", aEnemyIdle);
    e2.registerAnimation("turnAround", aEnTurnAround);
    e2.registerAnimation("walkUp", aEnWalkUp);
    e2.registerAnimation("walkDown", aEnWalkDown);
    e2.registerAnimation("walkLeft", aEnWalkLeft);
    e2.registerAnimation("walkRight", aEnWalkRight);
    e3.registerAnimation("idle", aEnemyIdle);
    e3.registerAnimation("turnAround", aEnTurnAround);
    e3.registerAnimation("walkUp", aEnWalkUp);
    e3.registerAnimation("walkDown", aEnWalkDown);
    e3.registerAnimation("walkLeft", aEnWalkLeft);
    e3.registerAnimation("walkRight", aEnWalkRight);
    e4.registerAnimation("idle", aEnemyIdle);
    e4.registerAnimation("turnAround", aEnTurnAround);
    e4.registerAnimation("walkUp", aEnWalkUp);
    e4.registerAnimation("walkDown", aEnWalkDown);
    e4.registerAnimation("walkLeft", aEnWalkLeft);
    e4.registerAnimation("walkRight", aEnWalkRight);
    e5.registerAnimation("idle", aEnemyIdle);
    e5.registerAnimation("turnAround", aEnTurnAround);
    e5.registerAnimation("walkUp", aEnWalkUp);
    e5.registerAnimation("walkDown", aEnWalkDown);
    e5.registerAnimation("walkLeft", aEnWalkLeft);
    e5.registerAnimation("walkRight", aEnWalkRight);
    entityMap.put("upLineEnemy",e2);
    entityMap.put("downLineEnemy",e3);
    entityMap.put("leftLineEnemy",e4);
    entityMap.put("rightLineEnemy",e5);
    fill(255);
    noStroke();
}

public void defineMaps() {
    Character[][] map1 = 
    {
        {'W','F','T','F','T','L'},
        {'W','T','L','b','F','L'},
        {'W','V','L','F','T','L'},
        {'W','T','L','b','F','L'},
        {'W','F','T','F','T','L'} 
    };
    NavMap navmap1 = new NavMap(map1);
    navmap1.registerEntity(entityMap.get("player"),2,3);
    manager.registerMap(navmap1);

    Character[][] map2 = 
    {
        {'V','W','F','T','F'},
        {'T','W','T','L','T'},
        {'F','W','F','L','F'},
        {'T','W','T','L','T'},
        {'F','W','F','L','F'},
        {'T','F','T','L','T'} 
    };
    NavMap navmap2 = new NavMap(map2);
    navmap2.registerEntity(entityMap.get("player"),5,4);
    manager.registerMap(navmap2);

    Character[][] map3 = 
    {                   //C
        {'W','W','T','F','T','b','b','b','V'},
        {'W','W','F','W','F','T','F','T','F'},
        {'T','F','T','W','b','b','b','b','b'},
        {'F','W','W','W','F','T','F','T','F'},
        {'T','F','T','W','T','b','b','b','T'},//C
        {'W','W','F','W','b','b','b','b','F'},
        {'T','F','T','W','T','F','T','b','T'},
        {'F','W','W','W','F','b','F','b','F'},
        {'T','F','T','F','T','b','T','F','T'}
    };
    NavMap navmap3 = new NavMap(map3);
    navmap3.registerEntity(entityMap.get("player"),4,4);
    manager.registerMap(navmap3);

    Character[][] map4 = 
    {                   //C
        {'W','W','W','W','W','W','W','W','W'},
        {'W','W','F','T','F','W','F','T','F'},
        {'W','W','T','W','T','W','T','W','T'},
        {'W','W','F','W','F','W','F','W','F'},
        {'W','F','T','L','T','L','T','L','T'},//C
        {'W','W','F','W','F','W','F','W','F'},
        {'W','W','T','W','T','W','T','W','T'},
        {'W','W','F','W','F','W','F','W','F'},
        {'W','W','T','W','T','F','T','W','V'}
    };
    NavMap navmap4 = new NavMap(map4);
    navmap4.registerEntity(entityMap.get("downLineEnemy"),4,1);
    navmap4.registerEntity(entityMap.get("player"),8,2);
    manager.registerMap(navmap4); 

    Character[][] map5 = 
    {                   //C
        {'V','F','T','F','T','F','T','F','T'},
        {'b','b','b','b','b','b','b','b','F'},
        {'b','F','T','F','T','F','T','F','T'},
        {'b','T','b','b','b','b','b','b','b'},
        {'b','F','T','F','T','F','T','F','T'},//C
        {'b','L','L','L','L','L','L','L','F'},
        {'b','F','T','F','T','F','T','F','T'},
        {'b','T','L','L','L','L','L','L','L'},
        {'b','F','T','F','T','F','T','F','T'}
    };
    NavMap navmap5 = new NavMap(map5);
    navmap5.registerEntity(entityMap.get("player"),8,7);
    navmap5.registerEntity(entityMap.get("rightLineEnemy"),4,8);
    navmap5.registerEntity(entityMap.get("leftLineEnemy"),8,1);
    manager.registerMap(navmap5); 
}

public void defineHudElements() {

}


  public void settings() { size(1920, 1080, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Project2" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
